<!DOCTYPE html>
<html lang="en" dir="ltr" style="--color--primary-hue:202;--color--primary-saturation:79%;--color--primary-lightness:50">
  <head>
    <meta charset="utf-8" />
<meta name="Generator" content="Drupal 10 (https://www.drupal.org)" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="icon" href="/themes/custom/joachim_blog_theme/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="alternate" type="application/rss+xml" title="Joachim&amp;#039;s blog" href="https://joachim-n.github.io/planet/feed" />

    <title>Drupal Planet Posts | Joachim&#039;s blog</title>
    <link rel="stylesheet" media="all" href="/sites/default/files/css/css_ihN9gV-WXsqs_8HEEt45YyjirGu6jPu5ot_R6_FnoJc.css?delta=0&amp;language=en&amp;theme=joachim_blog_theme&amp;include=eJxtiksOgCAQxS4EciTD54no4Bhn1HB7jQtXbJqmaeSEqZDicPFXs7CPc6ljIM6jzqhwE5B6PRMHT1a0Udly79j5xoFkQ7NvjWvvUZ_FSBNFdcELzFVwi_s4VE4n4QEvZUJF" />
<link rel="stylesheet" media="all" href="/sites/default/files/css/css_1jXAH4oZpERf974X1bp6_kLxFzUh9NogUun0JLEBbNE.css?delta=1&amp;language=en&amp;theme=joachim_blog_theme&amp;include=eJxtiksOgCAQxS4EciTD54no4Bhn1HB7jQtXbJqmaeSEqZDicPFXs7CPc6ljIM6jzqhwE5B6PRMHT1a0Udly79j5xoFkQ7NvjWvvUZ_FSBNFdcELzFVwi_s4VE4n4QEvZUJF" />

    
    
<link rel="preload" href="/themes/custom/joachim_blog_theme/fonts/metropolis/Metropolis-Regular.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/themes/custom/joachim_blog_theme/fonts/metropolis/Metropolis-SemiBold.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/themes/custom/joachim_blog_theme/fonts/metropolis/Metropolis-Bold.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/themes/custom/joachim_blog_theme/fonts/lora/lora-v14-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
    <noscript><link rel="stylesheet" href="/themes/custom/joachim_blog_theme/css/components/navigation/nav-primary-no-js.css?sspisc" />
</noscript>
  </head>
  <body class="path-planet">
        <a href="#main-content" class="visually-hidden focusable skip-link">
      Skip to main content
    </a>
    
      <div class="dialog-off-canvas-main-canvas" data-off-canvas-main-canvas>
    
<div id="page-wrapper" class="page-wrapper">
  <div id="page">

          <header id="header" class="site-header" data-drupal-selector="site-header" role="banner">

                <div class="site-header__fixable" data-drupal-selector="site-header-fixable">
          <div class="site-header__initial">
            <button class="sticky-header-toggle" data-drupal-selector="sticky-header-toggle" role="switch" aria-controls="site-header__inner" aria-label="Sticky header" aria-checked="false">
              <span class="sticky-header-toggle__icon">
                <span></span>
                <span></span>
                <span></span>
              </span>
            </button>
          </div>

                    <div id="site-header__inner" class="site-header__inner" data-drupal-selector="site-header-inner">
            <div class="container site-header__inner__container">

              


<div id="block-joachim-blog-theme-site-branding" class="site-branding block block-system block-system-branding-block">
  
    
    <div class="site-branding__inner">
              <div class="site-branding__text">
        <div class="site-branding__name">
          <a href="/" title="Home" rel="home">Joachim&#039;s blog</a>
        </div>
      </div>
      </div>
</div>
<nav  id="block-joachim-blog-theme-main-menu" class="primary-nav block block-menu navigation menu--main" aria-labelledby="block-joachim-blog-theme-main-menu-menu" role="navigation">
            
  <h2 class="visually-hidden block__title" id="block-joachim-blog-theme-main-menu-menu">Main navigation</h2>
  
        
          <ul  class="menu menu--level-1">
            
                          
        
        
        <li class="menu__item menu__item--link menu__item--level-1">
                    
          <a href="/" class="menu__link menu__link--link menu__link--level-1" data-drupal-link-system-path="&lt;front&gt;">Home</a>

          
        </li>
      
                          
        
        
        <li class="menu__item menu__item--link menu__item--level-1">
                    
          <a href="/about" class="menu__link menu__link--link menu__link--level-1" data-drupal-link-system-path="node/1">About</a>

          
        </li>
          </ul>
  


  </nav>

<div class="header-nav-overlay" data-drupal-selector="header-nav-overlay"></div>


                          </div>
          </div>
        </div>
      </header>
    
    <div id="main-wrapper" class="layout-main-wrapper layout-container">
      <div id="main" class="layout-main">
        <div class="main-content">
          <a id="main-content" tabindex="-1"></a>
          
          <div class="main-content__container container">
            

  <div class="region region--highlighted grid-full layout--pass--content-medium">
    <div data-drupal-messages-fallback class="hidden messages-list"></div>

  </div>

            

  <div class="region region--breadcrumb grid-full layout--pass--content-medium">
    

<div id="block-joachim-blog-theme-breadcrumbs" class="block block-system block-system-breadcrumb-block">
  
    
      <div class="block__content">
        <nav class="breadcrumb" role="navigation" aria-labelledby="system-breadcrumb">
    <h2 id="system-breadcrumb" class="visually-hidden">Breadcrumb</h2>
    <div class="breadcrumb__content">
      <ol class="breadcrumb__list">
                  <li class="breadcrumb__item">
                          <a href="/" class="breadcrumb__link">Home</a>
                      </li>
              </ol>
    </div>
  </nav>

    </div>
  </div>

  </div>


                          <main role="main">
                

  <div class="region region--content-above grid-full layout--pass--content-medium">
    

<div id="block-joachim-blog-theme-page-title" class="block block-core block-page-title-block">
  
  

  <h1 class="title page-title">Drupal Planet Posts</h1>


  
</div>

  </div>

                

  <div class="region region--content grid-full layout--pass--content-medium" id="content">
    

<div id="block-joachim-blog-theme-content" class="block block-system block-system-main-block">
  
    
      <div class="block__content">
      <div class="views-element-container"><div class="view view-planet view-id-planet view-display-id-page_1 js-view-dom-id-316ee1e03be543adf30bb23eb7efbef40d409f57fbe7bdf78e4a2894c236baf8">
  
    
      
      <div class="view-content">
          <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/dorgflow-tool-automate-your-drupalorg-patch-workflow" rel="bookmark">
<span>Dorgflow: a tool to automate your drupal.org patch workflow</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Wed, 02/22/2017 - 23:14
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p>I’ve written previously about git workflow for working on drupal.org patches, and about how we don’t necessarily need to move to a github-style system on drupal.org, we just maybe need better tools for our existing workflow. It’s true that much of it is repetitive, but then repetitive tasks are ripe for automation. In the two years since I released Dorgpatch, a shell script that handles the making of patches for drupal.org issues, I’ve been thinking of how much more of the drupal.org patch workflow could be automated.</p>
<p>Now, I have released a new script, <a href="https://github.com/joachim-n/dorgflow">Dorgflow</a>, and the answer is just about everything. The only thing that Dorgflow doesn’t automate is uploading the patch to drupal.org (and that’s because drupal.org’s REST API is read-only). Oh, and writing the code to actually fix bugs or create new features. You still have to do that yourself, along with your cup of coffee.</p>
<p>So assuming you’ve made your own hot beverage of choice, how does Dorgflow work?</p>
<p>Simply! To start with, you need to have an up to date git clone of the project you want to work on, be it Drupal core or a contrib project.</p>
<p>To start work on an issue, just do:</p>
<pre><code>$ dorgflow https://www.drupal.org/node/123456
</code></pre>
<p>You can copy and paste the URL from your browser. It doesn’t matter if it has an anchor link on the end, so if you followed a link from your issue tracker and it has ‘#new’ at the end, or clicked down to a comment and it has ‘#comment-1234’ that’s all fine.</p>
<p>The first thing this comment does it make a new git branch for you, using the issue number and the name. It then also downloads and applies all the patch files from the issue node, and makes a commit for each one. Your local git now shows you the history of the work on the issue. (Note though that if a patch no longer applies against the main branch, then it’s skipped, and if a patch has been set to not be displayed on the issue’s file list, then it’s skipped too.)</p>
<p>Let’s see how this works with an actual issue. Today I wanted to review the patch on an issue for Token module. The issue URL is https://www.drupal.org/node/2782605. So I did:</p>
<pre><code>$ dorgflow https://www.drupal.org/node/2782605
</code></pre>
<p>That got me a git history like this:</p>
<pre><code>  * 6d07524 (2782605-Move-list-of-available-tokens-from-Help-to-Reports) Patch from Drupal.org. Comment: 35; URL: https://www.drupal.org/node/2782605#comment-11934790; file: token-move-list-of-available-tokens-2782605-34.patch; fid 5784728. Automatic commit by dorgflow.
 * 6f8f6e0 Patch from Drupal.org. Comment: 15; URL: https://www.drupal.org/node/2782605#comment-11666939; file: 2782605-13.patch; fid 5710235. Automatic commit by dorgflow.
 /
* a3b68cc (8.x-1.x) Issue #2833328 by Berdir: Handle bubbleable metadata for block title token replacements
* [older commits…]
</code></pre>
<p>What we can see here is:</p>
<ul>
<li>Git is now on a feature branch, called ‘2782605-Move-list-of-available-tokens-from-Help-to-Reports’. The first part is the issue number, and the rest is from the title of the issue node on drupal.org.</li>
<li>Two patches were found on the issue, and a commit was made for each one. Each patch’s commit message gives the comment index where the patch was posted, the URL to the comment, the patch filename, and the patch file entity ID (these last two are less interesting, but are used by Dorgflow when you update a feature branch with newer patches from an issue).</li>
</ul>
<p>The commit for patch 35 will obviously only show the difference between it and patch 15, an interdiff effectively. To see what the patch actually contains, take a diff from the master branch, 8.x-1.x.</p>
<p>(As an aside, the trick to applying a patch that’s against 8.x-1.x to a feature branch that already has commit for a patch is that there is a way to check out files from any git commit while still keeping git’s HEAD on the current branch. So the patch applies, because the files look like 8.x-1.x, but when you make a commit, you’re on the feature branch. Details are on <a href="http://stackoverflow.com/questions/13896246/reset-git-to-commit-without-changing-head-to-detached-state">this Stack Overflow question</a>.)</p>
<p>At this point, the feature branch is ready for work. You can make as many commits as you want. (You can rename the branch if you like, provided the ‘2782605-’ part stays at the beginning.) To make your own patch with your work, just run the Dorgflow script without any argument:</p>
<pre><code>$ dorgflow
</code></pre>
<p>The script detects the current branch, and from that, the issue number, and then fetches the issue node from drupal.org to get the number of the next comment to use in the patch filename. All you now have to do is upload the patch, and post a comment explaining your changes.</p>
<p>Alternatively, if you’re a maintainer for the project, and the latest patch is ready to be committed, you can do the following to put git into a state where the patch is applied to the main development branch:</p>
<pre><code>$ dorgflow commit
</code></pre>
<p>At that point, you just need to obtain the git commit command from the issue node. (Remember the drupal standard git message format, and to check the attribution for the work on the issue is correct!)</p>
<p>What if you’ve previously reviewed a patch, and now there’s a new one? Dorgflow can download new patches with this command:</p>
<pre><code>$ dorgflow update
</code></pre>
<p>This compares your feature branch to the issue node’s patches, and any patches you don’t yet have get new commits.</p>
<p>If you’ve made commits for your own work as well, then effectively there’s a fork in play, as your development in your commits and the other person’s patch are divergent lines of development. Appropriately, Dorgflow creates a separate branch. Your commits are moved onto this branch, while the feature branch is rewound to the last patch that was already there, and then has the new patches applied to it, so that it now reflects work on the issue. It’s then up to you to do a git merge of these two branches in order to combine the two lines of development back into one.</p>
<p>Dorgflow is still being developed. There are a few ideas for further features in the issue queue on github (not to mention a couple of bugs for some of the various possible cases the update command can encounter). I’m also pondering whether it’s worth the effort to convert the script to use Symfony Console; feel free to chime in with any opinions on the issue for that.</p>
<p>There are tests too, as it’s pretty important that a script that does things to your git repository does what it’s supposed to (though the only command that does anything destructive is ‘dorgflow cleanup’, which of course asks for confirmation). Having now written this, I’m obviously embarking upon cleaning it up and to some extent rewriting it, though I do have the excuse that the early weeks of working on this were the days after the late nights awake with my newborn daughter, and so the early versions of the code were written in a haze of sleep deprivation. If you’d like to submit a pull request, please do check in with me first on an issue to ensure it’s not going to clash with something I’m partway through changing.</p>
<p>Finally, if you find this as useful as I do (this was definitely an itch I’ve been wanting to scratch for a long time, as well as being a prime case of condiment-passing), please tell other Drupal developers about it. Let’s all spend less time downloading, applying, and rolling patches, and more time writing Drupal code!</p></div>
      
  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/changing-type-node" rel="bookmark">
<span>Changing the type of a node</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Mon, 01/16/2017 - 22:22
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p>There’s an old saying that no information architecture survives contact with the user. Or something like that. You’ll carefully design and build your content types and taxonomies, and then find that the users are actually not quite using what you’ve built in quite the way it was intended when you were building it.</p>
<p>And so there comes a point where you need to grit your teeth, change the structure of the site’s content, and convert existing content.</p>
<p>Back on Drupal 7, I wrote a plugin for Migrate which handled migrations <em>within</em> a single Drupal site, so for example from nodes to a custom entity type, or from one node type to another. (The <a href="https://www.drupal.org/node/1883112">patch works</a>, though I never found the time to polish it sufficiently to be committed.)</p>
<p>On Drupal 8, without the time to learn the new version of Migrate, I recently had to cobble something together quickly.</p>
<p>Fortunately, this was just changing the type of some nodes, and where all the fields were identical on both source and destination node types.  Anything more complex would definitely require Migrate.</p>
<p>First, I created the new node type, and cloned all its fields from the old type to the new type. Here I took the time to update some of the <a href="https://www.drupal.org/project/field_tools">Field Tools</a> module’s functionality to Drupal 8, as it pays off to have a single form to clone fields rather than have to add them to the new node type one by one.</p>
<p>Field Tools also copies display settings where form and view modes match (in other words, if the source bundle has a ‘teaser’ display mode configured, and the destination also has a ‘teaser’ display mode that’s enabled for custom settings, then all of the settings for the fields being cloned are copied over, with field groups too).</p>
<p>With all the new configuration in place, it was now time to get down to the content. This was plain and simple a hack, but one that worked fine for the case in question. Here’s how it went…</p>
<p>We basically want to change the bundle of a bunch of nodes. (Remember, the ‘bundle’ is the generic name for a node type. Node types are bundles, as taxonomy vocabularies are bundles.) The data for a single node is spread over lots of tables, and most of these have the bundle in them.</p>
<p>On Drupal 8 these tables are:</p>
<ul>
<li>the entity base table</li>
<li>the entity data table</li>
<li>the entity revision data table</li>
<li>each field data table</li>
<li>each field data revision table</li>
</ul>
<p>(It’s not entirely clear to me what the separation between base table and data table is for. It looks like it might be that base table is fields that don’t change for revisions, and data table is for fields that do. But then the language is on the base table, and that can be changed, and the created timestamp is on the data table, and while you can change that, I wouldn’t have thought that’s something that has past values kept. Answers on a postcard.)</p>
<p>So we’re basically going to hack the bundle column in a bunch of tables. We start by getting the names of these tables from the entity type storage:</p>
<pre><code>$storage = \Drupal::service('entity_type.manager')-&gt;getStorage('node');

// Get the names of the base tables.
$base_table_names = [];
$base_table_names[] = $storage-&gt;getBaseTable();
$base_table_names[] = $storage-&gt;getDataTable();
// (Note that revision base tables don't have the bundle.)
</code></pre>
<p>For field tables, we need to ask the table mapping handler:</p>
<pre><code>$table_mapping = \Drupal::service('entity_type.manager')-&gt;getStorage('node')
  -&gt;getTableMapping();

// Get the names of the field tables for fields on the service node type.
$field_table_names = [];
foreach ($source_bundle_fields as $field) {
  $field_table = $table_mapping-&gt;getFieldTableName($field-&gt;getName());
  $field_table_names[] = $field_table;

  $field_storage_definition = $field-&gt;getFieldStorageDefinition();
  $field_revision_table = $table_mapping
    -&gt;getDedicatedRevisionTableName($field_storage_definition);

  // Field revision tables DO have the bundle!
  $field_table_names[] = $field_revision_table;
}
</code></pre>
<p>(Note the inconsistency in which tables have a bundle field and which don’t! For that matter, surely it’s redundant in all field tables? Does it improve the indexing perhaps?)</p>
<p>Then, get the IDs of the nodes to update. Fortunately, in this case there were only a few, and it wasn’t necessary to write a batched hook_update_N().</p>
<pre><code>// Get the node IDs to update.
$query = \Drupal::service('entity.query')-&gt;get('node');
// Your conditions here!
// In our case, page nodes with a certain field populated.
$query-&gt;condition('type', 'page');
$query-&gt;exists(‘field_in_question’);
$nids = $query-&gt;execute();
</code></pre>
<p>And now, loop over the lists of tables names and hack away!</p>
<pre><code>// Base tables have 'nid' and 'type' columns.
foreach ($base_table_names as $table_name) {
  $query = \Drupal\Core\Database\Database::getConnection('default')
    -&gt;update($table_name)
    -&gt;fields(['type' =&gt; 'service'])
    -&gt;condition('nid', $service_nids, 'IN')
    -&gt;execute();
}
// Field tables have 'entity_id' and 'bundle' columns.
foreach ($field_table_names as $table_name) {
  $query = \Drupal\Core\Database\Database::getConnection('default')
    -&gt;update($table_name)
    -&gt;fields(['bundle' =&gt; 'service'])
    -&gt;condition('entity_id', $service_nids, 'IN')
    -&gt;execute();
}
</code></pre>
<p>Node-specific tables use ‘nid’ and ‘type’ for their names, because those are the base field names declared in the entity type class, whereas Field API tables use the generic ‘entity_id’ and ‘bundle’. The mapping between these two is declared in the entity type annotation’s entity_keys property.</p>
<p>This worked perfectly. The update system takes care of clearing caches, so entity caches will be fine. Other systems may need a nudge; for instance, Search API won’t notice the changed nodes and its indexes will <a href="https://www.drupal.org/node/2749101">literally need turning off and on again</a>.</p>
<p>Though I do hope that the next time I have to do something like this, the amount of data justifies getting stuck into using Migrate!</p></div>
      
  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/what-goes-drupal-code-builder" rel="bookmark">
<span>What goes on in Drupal Code Builder?</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Sun, 05/15/2016 - 13:13
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p><a href="https://github.com/drupal-code-builder/drupal-code-builder">Drupal Code Builder library</a> is the new library which powers <a href="https://www.drupal.org/project/module_builder">Module Builder</a>. I <a href="http://www.noreiko.com/blog/module-builder-announces-split-due-functionality-differences">recently split Module Builder up</a>, so Drupal Code Builder (DCB) is the engine for generating Drupal code, while what remains in the Module Builder module is just the UI.</p>
<p>DCB is an extensible framework, so if you wanted to have DCB create scaffold code for a particular Drupal component or system, you can.</p>
<p>DCB's API is documented in the README. It's based on the idea of tasks: for example, list the hooks and plugin types that DCB has parsed from the site code, analyze the site code to update that list, or generate code for a module. There are Task classes, and you call public methods on these to do something.</p>
<h2>The generators</h2>
<p>Broadly, there are three things you want to do with DCB: collect and analyze data about a Drupal codebase to learn about hooks and plugin types, report on that data, and actually generate some code.</p>
<p>The Generate task class is where the work of creating code begins. The other task classes are all pretty simple, or at least self-contained, but the Generate task is accompanied by a large number of classes in the DrupalCodeBuilder\Generate namespace. You can see from the file names that these represent all the different components that make up generated code.</p>
<p>Furthermore, as well as all inheriting from BaseGenerator, there are hierarchies which can probably be deduced from the names alone, where more specialized generators inherit from generic ones. For example, we have:</p>
<ul>
<li>File
<ul>
<li>PHPFile
<ul>
<li>ModuleCodeFile</li>
<li>PHPClassFile
<ul>
<li>Plugin</li>
<li>Service</li>
</ul>
</li>
<li>API (this one's for your mymodule.api.php file)</li>
</ul>
</li>
<li>YMLFile</li>
<li>Readme</li>
</ul>
</li>
</ul>
<p>and also:</p>
<ul>
<li>PHPFunction
<ul>
<li>HookImplementation
<ul>
<li>HookMenu</li>
<li>HookPermission</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>However, these hierarchies are only about code re-use. In terms of PHP code, HookImplementation is only related to ModuleCodeFile by the common BaseGenerator base class. As the process of code generation takes place, there will be a tree of components that represents components containing each other, but it's important to remember that class inheritance doesn't come into it.</p>
<p>Also, while the generators in the hierarchies above clearly represent some tangible part of the code we're going to generate, some are more abstract, such as Module and Hooks. These aren't abstract in the OO sense, as they will get instantiated, but I think of them as abstract in the sense that they're not concrete and are responsible for code across different files. (Suggestions for a better word to describe them please!)</p>
<p>The process of generating code starts with a call to the Generate task's generateComponent() method. The host UI application (such as Module Builder module, or the Drush command) passes it an array of data that looks something like this:</p>
<pre><code>[
  'base' =&gt; 'module',
  'root_name' =&gt; 'mymodule,
  'readable_name' =&gt; 'My module',
  'hooks' =&gt; [
    'form_alter' =&gt; TRUE,
    'install' =&gt; TRUE,
  ],
  'plugins =&gt; [
    0 =&gt; [
      'plugin_type' =&gt; 'block',
      'plugin_name' =&gt; 'my_plugin',
      'injected_services' =&gt; [
        'current_user',
      ],
    ],
  ],
  'settings_form' =&gt; TRUE,
  'readme' =&gt; TRUE,
]
</code></pre>
<p>(How you get the specification for this array as a list of properties and their expected format is a detailed topic of its own, which will be covered later. For now, we're jumping in at the point where code is generated.)</p>
<h2>Assembling components</h2>
<p>The first job for the Generate task class is to turn this array of data into a list of generator classes for the necessary components.</p>
<p>This list is built up in a cascade, where each component gets to request further components, and those get to request components too, and so on, until we reach components that don't request anything. We start with the root component that was initially requested, Module, let that request components, and then repeat the process.</p>
<p>This is best illustrated with the AdminSettingsForm generator. This implements the requiredComponents() method to request:</p>
<ul>
<li>a permission</li>
<li>a router item (on Drupal 7 that's a menu item, but in DCB we refer to these a router item whatever the core Drupal version)</li>
<li>a form</li>
</ul>
<p>In turn, the Permission generator requests a permissions YAML file. You'll see that there are two Permission generators, each with a version suffix. The Permission7 generator requests a hook_permission() hook, which in turn requests a .module file. The Permission8 generator is somewhat simpler, and just requests a YMLFile component.</p>
<p>Meanwhile, the router item requests a routing.yml file on D8, and a hook_menu() on D7.</p>
<p>These two parts of the cascade end when we reach the various file generators: ModuleCodeFile and YMLFile don't request anything. The process that gathers all these generators works iteratively: every iteration it calls requiredComponents() on all the components the previous iteration gave it, and it only stops once an iteration produces no new components. It's safe to request the same component multiple times; in the D7 version of our example, both our hook_menu() and hook_permission() will request a ModuleCodeFile component that represents the .module file. The cascade system knows to either combine these two requests into one component, or ignore the second if it's identical to what's already been requested.</p>
<p>We now have a list of about a dozen or so components, each of which is an instantiated Generator object. Some represent files, some represent functions, and some like Hooks represent a more vague concept of the module 'having some hooks'. There's also the Module generator which started the whole process, whose requiredComponents() did most of the work of interpreting the given array of data.</p>
<h2>Assembling a tree of components</h2>
<p>The second part of the process is to assemble this flat list of components into a tree. This is where the notion of which component contains others does come into play. This is a different concept from requested components: a component can request something that it won't end up containing, as we saw with the AdminSettingsForm, which requests a permission.</p>
<p>The Generate task calls the containingComponent() method on each component, and this is used to assemble an array of parentage data. There's nothing fancy or recursive going on here; the tree is just an array whose keys are the identifiers of components, and whose values are arrays of the child component identifiers.</p>
<p>This tree now represents a structure of components where child items will produce code to be included in their parents. One part of this structure could be represented like this:</p>
<ul>
<li>module
<ul>
<li>routing.yml
<ul>
<li>router item</li>
</ul>
</li>
<li>permission.yml
<ul>
<li>permission</li>
</ul>
</li>
<li>.install
<ul>
<li>hook_install()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Some components, such as the Hooks component, are no longer around now: their job was to be a sort of broker for other components in the requesting phase, and they're no longer involved. The root component, Module, is the root of the tree. All the files we'll be outputting are its immediate children. (This is not a file hierarchy, folders are not represented here.)</p>
<h2>Assembling file contents</h2>
<p>We now have everything we need to start actually generating some code. This is done in a way that's very similar to Drupal's Render API: we recurse into the tree, asking each component to return some content both from itself and its children.</p>
<p>So for example, the router items contribute some lines to the routing.yml file, which then turns them into YAML. The .install component, which is an instance of ModuleCodeFile, produces a @file docblock, and then gets the docblock, function declaration, and function body from the hook_install component, and glues them all together.</p>
<p>Finally, each file component (the immediate children of the module component in the tree) gets to say what its file name and path should be.</p>
<p>So the Generate task has an array of data about files, where each item has a file name, file path, and file contents. This is returned to the caller to be output to the user, or written to the filesystem. Module Builder presents the files in a form, and allows the files to be written. The Drush command outputs them to terminal and optionally writes them too.</p>
<h2>Extending it with new components</h2>
<p>The best way to add new things for DCB to generate is to inherit from existing basic classes. If these don’t provide the flexibility, there’s always a case to be made to give them more configurable options: for example, the AdminSettingsForm class inherits from Form, but neither of those do very little for the actual generated form class, as the work for that is mostly done by the PHPClass class.</p>
<p>The roadmap for DCB at the moment consists of the following:</p>
<ul>
<li>Generalize the injected services functionality that’s already in Plugins, so generated Form classes and Services can have them too.</li>
<li>Add Forms as a basic component that you can request to generate. (It’s currently there only as a base for the AdminSettingsForm generator.)</li>
</ul>
<p>And as ever, keep adding tests, keep refactoring and improving the code. But I'm always interested in hearing new ideas (or you know, better yet, patches) in the issue queue.</p></div>
      
  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/lazy-maintainers-handbook-part-1-frequent-releases" rel="bookmark">
<span>The Lazy Maintainer&#039;s Handbook, Part 1: Frequent Releases</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Thu, 03/31/2016 - 00:59
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p><em>Every now and then I think about writing a series of posts called 'The Lazy Maintainer's Handbook', covering various aspects of how to maintain a project (or several) on drupal.org without it being a huge burden on your time (which a lot of people, and companies, think is the case). However, I never get much past the pondering stage. Since it's safe to say that I'm never going to manage to come up with the right order to write these in, I'm just going to start in the middle. Here goes.</em></p>
<p>Like with all software, bugs are a problem in the world of Drupal. In Drupal contrib, like with any software that has releases, we can classify bugs into three types:</p>
<ul>
<li>bugs which are reported, but have no fix,</li>
<li>bugs which have a fix, but the patch hasn't been committed,</li>
<li>bugs which have been fixed, but are not part of a release yet.</li>
</ul>
<p>The first and second type can involve a fair amount of work, and I will cover in another post in the future how much a LM can or should do about them.</p>
<p>The third type though is where the LM can really shine: all that needs to be done here is to make a release. What could be simpler? And let's be clear, making a release is a very quick job. I can do the whole thing in about a minute (though I've not timed it, yet).</p>
<p>For one thing, if you're still writing the release notes by hand, then <em>stop</em>: <a href="https://www.drupal.org/project/grn">Git Release Notes for Drush</a> does that for you.</p>
<p>Here's my process:</p>
<ul>
<li>
<code>$ git tag</code> This lists all the existing tags, so I can see what the next release number should be.</li>
<li>
<code>$ git tag 7.x-1.2</code> This creates the tag for the new release.</li>
<li>At this point, it's a good idea to check this in a graphical git client, to check for stupid mistakes like making the tag on a local development branch, or the wrong major branch. (I've done that at least once.)</li>
<li>
<code>$ git push origin 7.x-1.2</code> This creates the tag on the remote repository.</li>
<li>
<code>$ drush release-notes</code> This creates the release notes, using all the commit messages between the previous commit and the commit you just made. (Another reason to use the <a href="https://www.drupal.org/node/52287">standard format for commit messages</a>: it will turn the #12345 issue numbers into tags for d.org to then render as links.)</li>
<li>Select the output from the command and copy it.</li>
<li>Go to your project's page on d.org and click the 'Add new release' link.</li>
<li>Select the new tag.</li>
<li>Paste the release notes and save the node.</li>
</ul>
<p>I speed this up even more by having a bash alias for 'drush release-notes | pbcopy', which on OS X puts the text output by the Drush command onto the clipboard, so I can skip the selecting and copying step.</p>
<p>It's quick, right? Fun, even! Why don't maintainers do it more often? The reasons I can think of are:</p>
<ul>
<li>the current branch HEAD (and thus -dev release) is unstable and badly broken</li>
<li>maintainers are worried about making releases too frequent and making site builders update all the time</li>
<li>maintainers have fallen prey to the 'just one more fix' syndrome, and are waiting for another issue (or issues) to be resolved.</li>
</ul>
<p>Let's address these shall we?</p>
<h2>The branch is unstable</h2>
<p>This can happen when you're still on alpha releases, and something's caused you to take a new direction in development. This is a tough case: there's no going back, and you're stuck going forward. The only thing I would advise here is to look at the git history since the last release and see if there's a commit between then and now that could be tagged as the next alpha: for instance if the first few commits after the alpha were simple bug fixes. To try to prevent this problem, I recommend making a release immediately before you take a new direction in development, and if it's a very large rewrite, starting a new major branch, even if that means abandoning the 1.x branch at the alpha stage.</p>
<p>If a major rewrite happens and you're on beta releases or stable releases, then you're doing it wrong: a major rewrite should be cause to start a new major branch.</p>
<h2>The last release was recent, and users may dislike frequent releases</h2>
<p>Inspecting and testing new releases takes time. More importantly, perhaps, it has quite a high cognitive cost, as for each module you update, you need to review the release notes to look for any changes that might affect your site's functionality, and any parts of your site's codebase that make use of that module's code. It's also a bit stressful, because if something does break, it could be in a part of the site you don't think to check, so the first you'll hear of it is when your client or project manager calls in a panic two days later.</p>
<p>Understandably then, a lot of developers and site builders put off module updates, or don't bother with them until there's a security release.</p>
<p>This may be a time saving, but I don't believe it's an effort saving. Suppose you're on release 1.0 and releases 1.1 and then 1.2 come along. You can either upgrade to each one when it comes out, or you wait for 1.2 and then upgrade straight to that.</p>
<p>Doing two upgrades seems like more work, because you're only having to check the site once.</p>
<p>But I would counter that it's less overall cognitive load, because each single release has fewer changes. If releases are frequent, and include only up to a dozen or so commits, then it's easier to scan down the list of issues in the release notes, and maybe see that they're all very minor bug fixes, or clearly only affect functionality that your site doesn't use.</p>
<p>Ultimately, I don't think postponing upgrades pays off, because eventually, you'll have to bite the bullet and upgrade past several version numbers. Worse, you may have your hand forced when a security update comes along, and you'll be in the situation of having to read the release notes for all the versions you skipped and assessing them, <em>while your site is on fire</em>.</p>
<p>So I think small, frequent releases are actually a good thing, even from the point of view of existing users.</p>
<p>From the point of view of new users, they're a great thing: new users get better code, with fixed bugs. And that applies to existing users as well of course.</p>
<p>(A future episode in this series will cover an idea I've had for ages, of a metric for when you should do a release: after so many commits or weeks have passed.)</p>
<h2>You're waiting for just one more fix</h2>
<p>Don't. It might never come. In my experience, it probably won't. You'll think to yourself, 'just one more week and someone will review this patch', or 'I'll write a patch for this in the next week'. That week becomes two, and a month, and a year, and even more. I've seen comments on issues called 'Plan for a 1.0 release' where the maintainer says 'I'll make a release in the next two weeks' and that comment is over a year old. I saw one of those comments recently that was two years old. It was mine.</p>
<p>Fight the urge to wait for more fixes. Yes, you want your module to be good, even maybe perfect. But tell yourself: if you release now, you're still making it <em>better</em>. So here's what you need to do:</p>
<ul>
<li>If you're still not on a stable release, release another alpha or beta. The real purpose of unstable releases should be to get people to test your code. You really want them to be testing something recent, not code that's six months old.</li>
<li>If you're on stable releases, just release another one. Those issues you were waiting for can go in the next release (or the one after…)</li>
</ul>
<p>Hopefully that should assuage concerns regarding one's responsibility as a maintainer.</p>
<p>But as a <em>lazy</em> maintainer, what's the benefit to you?</p>
<ul>
<li>Your recent fixes are out there and in use. A bug isn't truly eradicated until a release is made that includes the fix.</li>
<li>Fewer duplicate issues filed. With fewer bugs that are fixed in dev but not in a release, there's less chance of people encountering them.</li>
<li>More users, because the age of the most recent release is a metric people use when evaluating a module.</li>
<li>Users are using a more recent version of the code, which means newer bugs are more likely to get caught. (Because seriously, how many people are actually trying out the dev release, unless they're forced to by unreleased fixes?)</li>
</ul>
<p>Get the code out. Dev code serves nobody. Releases are what matters.</p></div>
      
  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/module-builder-announces-split-due-functionality-differences" rel="bookmark">
<span>Module Builder announces split, due to functionality differences</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Sun, 02/28/2016 - 23:28
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p>For Drupal 8, <a href="https://www.drupal.org/project/module_builder">Module Builder</a> is undergoing some big changes. It still builds hooks, a README file, an api.php file, permissions, an admin settings form, but now also builds plugins, services, routing items, and its ability to scan your codebase to learn about hooks invented by any of your modules is now extended to plugin types too. And it's actually been available for Drupal 8 for quite some time, but up till now only as the Drush plugin version.</p>
<p>I've now released the D8 version of the module, so you can use an admin UI in Drupal which lets you select the components you want in a form. Unlike Drupal 7 though, the options you enter for your module to generate are stored in a config entity, so you can generate code and then go back and tweak the settings and generate it again, as often as you like.</p>
<p>The big change isn't any of these though. The big change is that Module Builder is being split up.</p>
<p>For a very long time, the Module Builder codebase has been three things in one. Back when I added Drush support (in 2009, according to the git log), it made sense to gradually refactor the code into three parts: the Drupal module UI, the Drush commands, and the common code that does the actual work of generating code based on some parameters (such as which hooks you want, the module name, etc).</p>
<p>That core code has undergone a lot of changes. It's gone from just working with hooks, to a framework that's extensible with new component types. So for example, it's possible to request simply 'an admin form', and the generating code knows to produce the code for the form, the admin permission, and the router item. So that's one component that in fact produces form functions, hook_permission(), hook_menu() on Drupal 7, form class, permissions.yml, routing.yml on Drupal 8. Because Module Builder also works on multiple versions of Drupal (the code to produce Drupal 5 code is even still in there, if you have cause to try it, let me know if it still works!).</p>
<p>Having this multiple-version code within a Drupal module that's only for single version is a source of problems and confusion. The 7.x-2.x version of the project contains a module that's only for Drupal 7, but also the core code and the Drush plugin that both work on all versions. It also increases maintenance work, if we want to the older versions to keep receiving improvements to the generating code.</p>
<p>Hence the split. Module Builder is being divided into three parts:</p>
<ul>
<li>The core code of Module Builder has been moved to a separate library, which is called Drupal Code Builder to distinguish it.</li>
<li>The Module Builder project is from now on just Drupal module, which requires the Drupal Code Builder library.</li>
<li>The Drush plugin will be moving too, and will also require the Drupal Code Builder library.</li>
</ul>
<p>So to summarize, the situation is now as follows:</p>
<ul>
<li>To build modules in a Drupal UI, on Drupal 8, you need:
<ul>
<li>
<a href="https://www.drupal.org/project/module_builder">Module Builder 8.x-3.x</a> (see the README for instructions)</li>
<li>
<a href="https://github.com/drupal-code-builder/drupal-code-builder">Drupal Code Builder library</a>
</li>
</ul>
</li>
<li>To build modules with Drush, on any version, you need:
<ul>
<li>Module Builder 7.x-2.x, installed as a Drush command plugin (again, see the README). But note this will shortly be changing when the Drush command moves out of the d.org project too.</li>
</ul>
</li>
<li>To build modules in a Drupal UI, on Drupal 7, you need:
<ul>
<li>Module Builder 7.x-2.x. I will probably release a 7.x-3.x at some point which requires the Drupal Code Builder library, so that the Drupal 7.x UI gets new features that are released in the library.</li>
</ul>
</li>
</ul>
<p>I'll be writing a post soon about how Drupal Code Builder works, so if you're interested in making Drupal Code Builder make something new, look out for that.</p></div>
      
  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/importing-wysiwyg-image-files-body-text-migrate" rel="bookmark">
<span>Importing wysiwyg image files in body text with Migrate</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Tue, 01/05/2016 - 21:38
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p>Migrate module makes the assumption that for each item in your source, you're importing one item into Drupal, and that's baked in pretty deep.</p>
<p>So how do you handle source items where there is body text containing multiple inline images, which should be imported to file entities? For each single source item, ultimately imported as a node, you also have a variable number of images: a one-to-many source to destination relationship.</p>
<p>One way is to simply import the image files at the same time as the nodes whose body text they are in. In the prepareRow() method of your migration class, you effectively do a mini-import, analysing the text, fetching the file data, saving the file locally, and then getting a file ID that you can use to replace into the body text. But doing that, you don't benefit from any of Migrate's helper classes for importing files, nor can you roll these back without writing further code: this isn't a Migration, capital M, it's just an import.</p>
<p>The better way is to write a second migration, to run before your node migration. It may seem like extra work to have to write a second migration class, but it pays off, and besides, since they both draw from the same source data, a lot of your code is already written. Copy-paste the class definition and the constructor as far as the field mappings. The code you would have put in prepareRow() to analyse the text goes somewhere else, but we're getting ahead of ourselves.</p>
<p>And it turns out that Migrate does allow for your single source items to yield multiple destination items: tucked away in the module's source classes and not mentioned in the examples (which do cover a great deal, are probably the most extensive examples of any contrib module all the same, it must be said) there are at least two (that I've found) places where the one-to-one correspondence can be skirted around.</p>
<p>The one that I used is only available when you use the MigrateSourceList source type, and furthermore when your list source is a set of files. As it happened, the source data I was working with on my project came in JSON files, one file per node to import, and with a body text field which contained references to image files which also needed to be imported.</p>
<p>MigrateSourceList is a source type that separates out the two concepts of listing your source items and processing each one. So unlike, say, the CSV source where the list and the item processing are both provided by the one class, with MigrateSourceList, you can say something like 'my list source is a directory listing, and each item is a JSON file', or 'my list source is a JSON file, and each item is an HTML file'. The MigrateSourceList class delegates the two jobs to further classes, which allows you to mix and match them. Your migration specifies them in the constructor:</p>
<pre><code>    $this-&gt;source = new MigrateSourceList(new MigrateListFiles($list_dirs, $base_dir),
      new MigrateItemFile($base_dir), $fields);
</code></pre>
<p>There's one more component in the system, and this is the crucial piece that allows us to have more than one destination item per source item: it's the MigrateContentParser class. This allows the files that MigrateListFiles to each return multiple items to MigrateSourceList.</p>
<p>The only implementation of this in Migrate is MigrateSimpleContentParser, which doesn't do much, so you'll want to subclass this for your particular case. It's fairly simple:</p>
<ul>
<li>setContent() — perform any processing on the content of the file. In my case, I needed to run it through drupal_json_decode() and grab the body text field, since the whole file was JSON representing a node.</li>
<li>getChunkCount() — process the file content to return a count of how many items for migration are contained in it.</li>
<li>getChunkIDs() — similar to getChunkCount(), but return IDs. You will probably end up using a common helper method for this and getChunkCount(), as they do the same sort of work. The IDs you return can be anything you like; in my case they were GUIDs. They are appended to the ID for the file to form the overall source ID.</li>
<li>getChunk() — given a chunk ID (one of the ones you provided in getChunkIDs()), return the actual data for that item. Again, you may want to use a common helper. In my case, here I merely returned the ID itself, since the images to migrate were on a remote server and accessed by their GUID.</li>
</ul>
<p>I submitted a patch to make it a bit easier to deal with the case where files might contain either one or many chunks (or even none): by default, a file providing only one chunk doesn't get to return a chunk ID, which wasn't working for my case. The patch (committed but not yet in a release) adds <a href="https://www.drupal.org/node/2550793">an option to override this</a> so you always know the ID of the chunk: in my case, the GUID for the image found inside the body text, which was always needed by the image migration code.</p>
<p>At the other end, I needed a custom subclass of MigrateItem to deal with the data returned by getChunk(). This just needs to implement getItem(), and it can pretty much return anything you like: this is the same source data item that your migration class gets to work with.</p>
<p>So to recap, as there's quite a few classes flying around helping one another here, we have MigrateListFiles which uses a custom MigrateContentParser implementation to extract items from the source data files, with possibly more than one item from a single file, and then MigrateSourceList uses MigrateListFiles along with a custom MigrateItem implementation.</p>
<p>The setup code in my migration's constructor then looks like this:</p>
<pre><code>    $parser = new CustomJSONBodyImagesParser();
    $list = new MigrateListFiles(
      // $list_dirs
      array($source_folder),
      // $base_dir
      $source_folder,
      // $file_mask
      '//',
      // $options
      array(),
      // MigrateContentParser $parser
      $parser
    );
    $item = new CustomImageGUIDItem();
    $this-&gt;source = new MigrateSourceList($list, $item, $fields);
</code></pre>
<p>The end result worked great, and the ability to rollback turned out to be very useful, when there turned out to be bad data here and there that needed to be cleaned up or skipped. But that's what always happens with migrations in my experience!</p></div>
      
  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/script-making-patches" rel="bookmark">
<span>A script for making patches</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Fri, 03/27/2015 - 13:46
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p>I have a standard format for patchnames: 1234-99.project.brief-description.patch, where 1234 is the issue number and 99 is the (expected) comment number. However, it involves two copy-pastes: one for the issue number, taken from my browser, and one for the project name, taken from my command line prompt.</p>
<p>Some automation of this is clearly possible, especially as I usually name my git branches 1234-brief-description. More automation is less typing, and so in true XKCD condiment-passing style, I've now written that script, which you can find on github as <a href="https://github.com/joachim-n/dorgpatch">dorgpatch</a>. (The hardest part was thinking of a good name, and as you can see, in the end I gave up.)</p>
<p>Out of the components of the patch name, the issue number and description can be deduced from the current git branch, and the project from the current folder. For the comment number, a bit more work is needed: but drupal.org now has a public API, so a simple REST request to that gives us data about the issue node including the comment count.</p>
<p>So far, so good: we can generate the filename for a new patch. But really, the script should take care of doing the diff too. That's actually the trickiest part: figuring out which branch to diff against. It requires a bit of git branch wizardry to look at the branches that the current branch forks off from, and some regular expression matching to find one that looks like a Drupal development branch (i.e., 8.x-4.x, or 8.0.x). It's probably not perfect; I don't know if I accounted for a possibility such as 8.x-4.x branching off a 7.x-3.x which then has no further commits and so is also reachable from the feature branch.</p>
<p>The other thing this script can do is create a tests-only patch. These are useful, and generally advisable on drupal.org issues, to demonstrate that the test not only checks for the correct behaviour, but also fails for the problem that's being fixed. The script assumes that you have two branches: the one you're on, 1234-brief-description, and also one called 1234-tests, which contains only commits that change tests.</p>
<p>The git workflow to get to that point would be:</p>
<ol>
<li>Create the branch 1234-brief-description
</li>
<li>Make commits to fix the bug
</li>
<li>Create a branch 1234-tests
</li>
<li>Make commits to tests (I assume most people are like me, and write the tests after the fix)
</li>
<li>Move the string of commits that are only tests so they fork off at the same point as the feature branch: git rebase --onto 8.x-4.x 1234-brief-description 1234-tests
</li>
<li>Go back to 1234-brief-description and do: git merge 1234-tests, so the feature branch includes the tests.
</li>
<li>If you need to do further work on the tests, you can repeat with a temporary branch that you rebase onto the tip of 1234-tests. (Or you can cherry-pick the commits. Or do cherry-pick with git rev-list, which is a trick I discovered today.)
</li>
</ol>
<p>Next step will be having the script make an interdiff file, which is a task I find particularly fiddly.</p>
</div>
      

<div class="field field--name-field-tags field--type-entity-reference field--label-above field--tags">
      <h3 class="field__label field--tags__label">Tags</h3>
    <ul class="links field__items field--tags__items">
          <li class="field--tags__item"><a href="/taxonomy/term/46" hreflang="en">git</a></li>
          <li class="field--tags__item"><a href="/taxonomy/term/49" hreflang="en">patching</a></li>
          <li class="field--tags__item"><a href="/taxonomy/term/54" hreflang="en">drupal.org</a></li>
          <li class="field--tags__item"><a href="/taxonomy/term/55" hreflang="en">workflow</a></li>
      </ul>
</div>

  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/git-based-patch-workflow-drupalorg-interdiffs-free" rel="bookmark">
<span>A git-based patch workflow for drupal.org (with interdiffs for free!)</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Thu, 11/27/2014 - 08:39
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p>There's been a lot of discussion about how we need github-like features on d.org. Will we get them? There's definitely many improvements in the pipeline to the way our issue queues work. Whether we actually need to replicate github is another debate (and my take on it is that I don't think we do).</p>
<p>In the meantime, I think that it's possible to have a good collaborative workflow with what we have right now on drupal.org, with just the issue queue and patches, and git local branches. Here's what I've gradually refined over the years. It's fast, it helps you keep track of things, and it makes the most of git's strengths.</p>
<h2>A word on local branches</h2>
<p>Git's killer feature, in my opinion, is local branches. Local branches allow you to keep work on different issues separate, and they allow you to experiment and backtrack. To get the most out of git, you should be making small, frequent commits.</p>
<p>Whenever I do a presentation on git, I ask for a show of hands of who's ever had to bounce on CMD-Z in their text editor because they broke something that was working five minutes ago. Commit often, and never have that problem again: my rule of thumb is to commit any time that your work has reached a state where if subsequent changes broke it, you'd be dismayed to lose it.</p>
<h2>Starting work on an issue</h2>
<p>My first step when I'm working on an issue is obviously:</p>
<div class="codeblock"><code>&nbsp; git pull</code></div>
<p>This gets the current branch (e.g. 7.x, 7.x-2.x) up to date. Then it's a good idea to reload your site and check it's all okay. If you've not worked on core or the contrib project in question in a while, then you might need to run update.php, in case new commits have added updates.</p>
<p>Now start a new local branch for the issue:</p>
<div class="codeblock"><code>&nbsp; git checkout -b 123456-foobar-is-broken</code></div>
<p>I like to prefix my branch name with the issue number, so I can always find the issue for a branch, and find my work in progress for an issue. A description after that is nice, and as git has bash autocompletion for branch names, it doesn't get in the way. Using the issue number also means that it's easy to see later on which branches I can delete to unclutter my local git checkout: if the issue has been fixed, the branch can be deleted!</p>
<p>So now I can go ahead and start making commits. Because a local branch is private to me, I can feel free to commit code that's a total mess. So something like:</p>
<div class="codeblock"><code>&nbsp; dpm($some_variable_I_needed_to_examine);<br>&nbsp; /*<br>&nbsp; // Commented-out earlier approach that didn't quite work right.<br>&nbsp; $foo += $bar;<br>&nbsp; */<br>&nbsp; // Badly-formatted code that will need to be cleaned up.<br>&nbsp; if($badly-formatted_code) { $arg++; }</code></div>
<p>That last bit illustrates an important point: commit code before cleaning up. I've lost count of the number of times that I've got it working, and cleaned up, and then broken it because I've accidentally removed an important line that was lost among the cruft. So as soon as code is working, I make a commit, usually whose message is something like 'TOUCH NOTHING IT WORKS!'. Then, start cleaning up: remove the commented-out bits, the false starts, the stray code that doesn't do anything, in small commits of course. (This is where you find it actually does, and breaks everything: but that doesn't matter, because you can just revert to a previous commit, or even use git bisect.)</p>
<h2>Keeping up to date</h2>
<p>Core (or the module you're working on) doesn't stay still. By the time you're ready to make a patch, it's likely that there'll be new commits on the main development branch (with core it's almost certain). And before you're ready, there may be commits that affect your ongoing work in some way: API changes, bug fixes that you no longer need to work around, and so on.</p>
<p>Once you've made sure there's no work currently uncommitted (either use git stash, or just commit it!), do:</p>
<div class="codeblock"><code>git fetch<br>git rebase BRANCH</code></div>
<p>where BRANCH is the main development branch that is being committed to on drupal.org, such as 8.0.x, 7.x-2.x-dev, and so on.</p>
<p>(This is arguably one case where a local branch is easier to work with than a github-style forked repository.)</p>
<p>There's lots to read about rebasing elsewhere on the web, and some will say that rebasing is a terrible thing. It's not, when used correctly. It can cause merge conflicts, it's true. But here's another place where small, regular commits help you: small commits mean small conflicts, that shouldn't be too hard to resolve.</p>
<h2>Making a patch</h2>
<p>At some point, I'll have code I'm happy with (and I'll have made a bunch of commits whose log messages are 'clean-up' and 'formatting'), and I want to make a patch to post to the issue:</p>
<div class="codeblock"><code>&nbsp; git diff 7.x-1.x &gt; 123456.PROJECT.foobar-is-broken.patch</code></div>
<p>Again, I use the issue number in the name of the patch. Tastes differ on this. I like the issue number to come first. This means it's easy to use autocomplete, and all patches are grouped together in my file manager and the sidebar of my text editor.</p>
<h2>Reviewing and improving on a patch</h2>
<p>Now suppose Alice comes along, reviews my patch, and wants to improve it. She should make her own local branch:</p>
<div class="codeblock"><code>&nbsp; git checkout -b 123456-foobar-is-broken</code></div>
<p>and download and apply my patch:</p>
<div class="codeblock"><code>&nbsp; wget PATCHURL<br>&nbsp; patch -p1 &lt; 123456.PROJECT.foobar-is-broken.patch</code></div>
<p>(Though I would hope she has a bash alias for 'patch -p1' like I do. The other thing to say about the above is that while wget is working at downloading the patch, there's usually enough time to double-click the name of the patch in its progress output and copy it to the clipboard so you don't have to type it at all.)</p>
<p>And finally commit it to her branch. I would suggest she uses a commit message that describes it thus:</p>
<div class="codeblock"><code>&nbsp; git commit -m "joachim's patch at comment #1"</code></div>
<p>(Though again, I would hope she uses a GUI for git, as it makes this sort of thing much easier.)</p>
<p>Alice can now make further commits in her local branch, and when she's happy with her work, make a patch the same way I did. She can also make an interdiff very easily, by doing a git diff against the commit that represents my patch.</p>
<h2>Incorporating other people's changes to ongoing work</h2>
<p>All simple so far. But now suppose I want to fix something else (patches can often bounce around like this, as it's great to have someone else to spot your mistakes and to take turns with). My branch looks like it did at my patch. Alice's patch is against the main branch (for the purposes of this example, 7.x-1.x).</p>
<p>What I want is a new commit on the tip of my local branch that says 'Alice's changes from comment #2'. What I need is for git to believe it's on my local branch, but for the project files to look like the 7.x-1.x branch. With git, there's nearly always a way:</p>
<div class="codeblock"><code>&nbsp; git checkout 7.x-1.x .</code></div>
<p>Note the dot at the end. This is the filename parameter to the checkout command, which tells git that rather than switch branches, you want to checkout just the given file(s) while staying on your current branch. And that the filename is a dot means we're doing that for the entire project. The branch remains unchanged, but all the files from 7.x-1.x are checked out.</p>
<p>I can now apply Alice's patch:</p>
<div class="codeblock"><code>&nbsp; wget PATCHURL<br>&nbsp; patch -p1 &lt; 123456.2.PROJECT.foobar-is-broken.patch</code></div>
<p>(Alice has put the comment ID after the issue ID in the patch filename.)</p>
<p>When I make a commit, the new commit goes on the tip of my local branch. The commit diff won't look like Alice's patch: it'll look like the difference between my patch and Alice's patch: effectively, an interdiff. I now make a commit for Alice's patch:</p>
<div class="codeblock"><code>&nbsp; git commit -m "Alice's patch at comment #2"</code></div>
<p>I can make more changes, then do a diff as before, post a patch, and work on the issue advances to another iteration.</p>
<p>Here's an example of my local branch for an issue on Migrate I've been working on recently. You can see where I made a bunch of commits to clean up the documentation to get ready to make a patch. Following that is a commit for the patch the module maintainer posted in response to mine. And following that are a few further tweaks that I made on top of the maintainer's patch, which I then of course posted as another patch.</p>
<p><img src="sites/default/files/article/image/git-local-branch-issue-workflow.png" width="457" height="257" alt="A screenshot of a git GUI showing the tip of a local branch, with a commit for a patch from another user."></p>
<p>(Notice how in a local branch, I don't feel the need to type terribly accurately for my commit messages, or indeed be all that clear.)</p>
<h2>Improving on our tools</h2>
<p>Where next? I'm pretty happy with this workflow as it stands, though I think there's plenty of scope for making it easier with some git or bash aliases. In particular, applying Alice's patch is a little tricky. (Though the stumbling block there is that you need to know the name of the main development branch. Maybe pass the script the comment URL, and let it ask d.org what the branch of that issue is?)</p>
<p>Beyond that, I wonder if any changes can be made to the way git works on d.org. A sandbox per issue would replace the passing around of patch files: you'd still have your local branch, and merge in and push instead of posting a patch. But would we have one single branch for the issue's development, which then runs the risk of commit clashes, or start a new branch each time someone wants to share something, which adds complexity to merging? And finally, sandboxes with public branches mean that rebasing against the main project's development can't be done (or at least, not without everyone know how to handle the consequences). The alternative would be merging in, which isn't perfect either.</p>
<p>The key thing, for me, is to preserve (and improve) the way that so often on d.org, issues are not worked on by just one person. They're a ball that we take turns pushing forward (snowball, Sisyphean rock, take your pick depending on the issue!). That's our real strength as a community, and whatever changes we make to our toolset have to be made with the goal of supporting that.</p>
</div>
      

<div class="field field--name-field-tags field--type-entity-reference field--label-above field--tags">
      <h3 class="field__label field--tags__label">Tags</h3>
    <ul class="links field__items field--tags__items">
          <li class="field--tags__item"><a href="/taxonomy/term/46" hreflang="en">git</a></li>
          <li class="field--tags__item"><a href="/taxonomy/term/6" hreflang="en">drupal planet</a></li>
          <li class="field--tags__item"><a href="/taxonomy/term/48" hreflang="en">issue queue</a></li>
          <li class="field--tags__item"><a href="/taxonomy/term/49" hreflang="en">patching</a></li>
      </ul>
</div>

  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/building-fast-and-flexible-application-uis-entity-operations" rel="bookmark">
<span>Building Fast and Flexible Application UIs with Entity Operations</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Tue, 11/18/2014 - 13:38
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p>Now I've finished the Big Monster Project of Doom that I've been on the last two years, I can talk more about some of the code that I wrote for it. I can also say what it was: it was a web application for activists to canvass the public for a certain recent national referendum (I'll let you guess which one).</p>
<p>One of the major modules I wrote was <a href="https://www.drupal.org/project/entity_operations">Entity Operations</a> module. What began as a means to avoid repeating the same code each time I needed a new entity type soon became the workhorse for the whole application UI.</p>
<p>The initial idea was this: if you want a custom entity type, and you want a UI for adding, editing, and deleting entities (much like with nodes), then you have to build this all yourself: hook_menu() items, various entity callbacks, form builders (and validation and submit handlers) for the entity form and the delete confirmation form. (The <a href="https://www.drupal.org/project/model">Model module</a> demonstrates this well.)</p>
<p>That's a lot of boilerplate code, where the only difference is the entity type's name, the base path where the entity UI sits, and the entity form builder itself (but even that can be generalized, as will be seen).</p>
<p>Faced with this and a project on which I knew from the start I was going to need a good handful of custom entities (for use with Microsoft Dynamics CRM, accessed with another custom module of mine, <a href="http://drupal.org/project/remote_entity">Remote Entity API</a>), I undertook to build a framework that would take away all the repetition.</p>
<p>An Entity UI is thus built by declaring:</p>
<ul>
<li>A base path (for nodes, this would be 'node'; we'll ignore the fact that in core, this path itself is a listing of content).</li>
<li>A list of subpaths to form the tabs, and the operation handler class for each one</li>
</ul>
<p>With this in hand, why stop at just the entity view and edit tabs? The operation handlers can output static content or forms: they can output anything. One of the most powerful enhancements I made to this early on was to write an operations handler that outputs a view. It's the same idea as the <a href="http://drupal.org/project/eva">EVA</a> module.</p>
<p>So for the referendum canvassing application, I had a custom Campaign entity, that functioned as an Organic Group, and had as UI tabs several different views of members, views of contacts in the Campaign's geographic area, views of Campaign group content (such as tasks and contact lists), and so on.</p>
<p>This approach proved very flexible and quick. The group content entities were themselves also built with this, so that, for example, Contact List entities had operations for a user to book the entity, input data, and release it when done working on it. These were built with custom operation handlers specific to the Contact List entity, subclassing the generic form operation handler.</p>
<p>An unexpected bonus to all this was how easy it was to expose form-based operations to Views Bulk Operations and Services (as 'targeted actions' on the entity). This allowed the booking and release operations to work in bulk on views, and also to be done via a mobile app over Services.</p>
<p>A final piece of icing on the cake was the addition of alternative operation handlers for entity forms that provide just a generic bare bones form that invokes Field API to attach field widgets. With these, the amount of code needed to build a custom entity type is reduced to just three functions:</p>
<ul>
<li>hook_entity_info(), to declare the entity type to Drupal core</li>
<li>hook_entity_operations_info(), to declare the operations that make up the UI</li>
<li><a href="https://www.drupal.org/node/2240921">callback_entity_access()</a>, which controls the access to the operations</li>
</ul>
<p>The module has a few further tricks up its sleeve. If you're using user permissions for your entities, there's a helper function to use in your hook_permission(), which creates permissions out of all the operations (so: 'edit foobar entities', 'book foobar entities', 'discombobulate foobar entities' and so on). The entity URI callback that Drupal core requires you to have can be taken care of by a helper callback which uses the entity's base path definition. There's a form builder that lets you easily embed form-based operations into the entity build, so that you can put the sort of operations that are single buttons ('publish', 'book', etc) on the entity rather than in a tab. And finally, the links to operation tabs can be added to a view as fields, allowing a list of entities with links to view, edit, book, discombobulate, and so on.</p>
<p>So what started as a way to simplify and remove repetitive code became a system for building a whole entity-based UI, which ended up powering the whole of the application.</p>
</div>
      
  </div>
  </article>
</div>
    <div class="views-row">

<article class="node node--type-article grid-full node--view-mode-full">
  <header class="layout--content-narrow">
    
            <h2 class="node__title">
        <a href="/blog/graphing-relationships-between-entity-types" rel="bookmark">
<span>Graphing relationships between entity types</span>
</a>
      </h2>
        
          <div class="node__meta">
              <div class="node__author-image">
          <div>
  </div>

        </div>
              <span>
          By <span><span>joachim</span></span>, Sun, 08/31/2014 - 21:00
        </span>
        
      </div>
      </header>
  <div class="node__content layout--content-narrow">
        
            <div class="text-content clearfix field field--name-body field--type-text-with-summary field--label-hidden field__item"><p>Another thing that was developed as a result of my big Commerce project (see <a href="http://www.noreiko.com/blog/ripple-effect">my previous blog post for the run-down of the various modules this contributed back to Drupal</a>) was a bit of code for generating a graph that represents the relationships between entity types.</p>
<p>For a site with a lot of entityreference fields it's a good idea to draw diagrams before you get started, to figure out how everything ties together. But it's also nice to have a diagram that's based on what you've built, so you can compare it, and refer back to it (not to mention that it's a lot easier to read than my handwriting).</p>
<p>The code for this never got released; I tried various graph engines that work with <a href="https://www.drupal.org/project/graphapi">Graph API</a>, but none of them produced quite what I was hoping for. It just sat in my local copy of Field Tools for the last couple of years (I didn't even make a git branch for it, that shows how rough it was!). Then yesterday I came across the <a href="http://sigmajs.org/">Sigma.js graph library</a>, and that inspired me to dig out the code and finish it off.</p>
<p>To give the complete picture, I've added support for the relationships that are formed between entity types by their schema fields: things like the uid property on a node. These are easily picked out of hook_schema()'s foreign keys array.</p>
<p>In the end, I found Sigma.js wasn't the right fit: it looks very pretty, but it expects you to dictate the position of the nodes in the canvass, which for a generated graph doesn't really work. There is a plugin for it that allows the graph to be force-directed, but that was starting to be too fiddly. Instead though, I found <a href="http://getspringy.com/">Springy</a>, that while maybe not quite as versatile, automatically lays out the graph nodes out of the box. It didn't take too long to write <a href="https://www.drupal.org/sandbox/joachim/2330333">a library module for using Springy with Graph API</a>.</p>
<p>Here's the result:</p>
<p><img src="sites/default/files/article/image/field-tools-graph-springy_0.png" width="785" height="487" alt="Graph showing relationships between entity types on a development Drupa site"></p>
<p>Because this uses Graph API, it'll work with any graph engine, not just Springy. So I'll be interested to see what people who are more familiar with graphing can make it do. To get something that looks like the above for your site, it's simple: install the 7.x-1.x-dev release of <a href="http://drupal.org/project/field_tools">Field Tools</a>, install <a href="https://www.drupal.org/project/graphapi">Graph API</a>, install <a href="https://www.drupal.org/sandbox/joachim/2330333">the Springy module</a>, and follow the instructions in the README of that last module for installing the Springy Javascript library.</p>
<p>The next stage of development for this tool is figuring out a nice way of showing entity bundles. After all, entityreference fields are on specific bundles, and may point to only certain bundles. However, they sometimes point to all bundles of an entity type. And meanwhile, schema properties are always on all bundles and point to all bundles. How do we represent that without the graph turning into a total mess? I'm pondering adding a form that lets you pick which entity types should be shown as separate bundles, but it's starting to get complicated. If you have any thoughts on this, or other ways to improve this feature, please share them with me in the Field Tools issue queue!</p>
</div>
      
  </div>
  </article>
</div>

    </div>
  
        <nav class="pager layout--content-medium" role="navigation" aria-labelledby="pagination-heading">
    <h4 id="pagination-heading" class="visually-hidden">Pagination</h4>
    <ul class="pager__items js-pager__items">
                    <li class="pager__item pager__item--control pager__item--first"><a href="/planet" title="Go to first page" class="pager__link"><span class="visually-hidden">First page</span><svg xmlns="http://www.w3.org/2000/svg" width="15px" height="16px" viewBox="0 0 15 16"><path d="M5.1,7.2l8.3-6C14.1,0.7,15,1.1,15,2V14c0,0.8-0.9,1.3-1.6,0.8l-8.3-6C4.6,8.4,4.6,7.6,5.1,7.2z M0,0h2v16H0V0z"/></svg></a></li>      
                    <li class="pager__item pager__item--control pager__item--previous"><a href="/planet/page/2" title="Go to previous page" rel="prev" class="pager__link"><span class="visually-hidden">Previous page</span><svg xmlns="http://www.w3.org/2000/svg" width="11" height="16" viewBox="0 0 11 16"><path d="M1.11201 7.19126L9.41183 1.15503C10.0728 0.674329 11 1.14648 11 1.96377V14.0362C11 14.8535 10.0728 15.3257 9.41183 14.845L1.11201 8.80874C0.562908 8.40939 0.562907 7.59061 1.11201 7.19126Z"/></svg></a></li>      
            
                    <li class="pager__item pager__item--number"><a href="/planet" title="Go to page 1" class="pager__link"><span class="visually-hidden">
              Page
            </span>
            1
                          </a></li>              <li class="pager__item pager__item--number"><a href="/planet/page/2" title="Go to page 2" class="pager__link"><span class="visually-hidden">
              Page
            </span>
            2
                          </a></li>              <li class="pager__item pager__item--active pager__item--number"><span class="visually-hidden">
              Current page
            </span>
            3
                      </li>              <li class="pager__item pager__item--number"><a href="/planet/page/4" title="Go to page 4" class="pager__link"><span class="visually-hidden">
              Page
            </span>
            4
                          </a></li>              <li class="pager__item pager__item--number"><a href="/planet/page/5" title="Go to page 5" class="pager__link"><span class="visually-hidden">
              Page
            </span>
            5
                          </a></li>              <li class="pager__item pager__item--number"><a href="/planet/page/6" title="Go to page 6" class="pager__link"><span class="visually-hidden">
              Page
            </span>
            6
                          </a></li>      
            
                    <li class="pager__item pager__item--control pager__item--next"><a href="/planet/page/4" title="Go to next page" rel="next" class="pager__link"><span class="visually-hidden">Next page</span><svg xmlns="http://www.w3.org/2000/svg" width="11" height="16" viewBox="0 0 11 16"><path d="M1.11201 7.19126L9.41183 1.15503C10.0728 0.674329 11 1.14648 11 1.96377V14.0362C11 14.8535 10.0728 15.3257 9.41183 14.845L1.11201 8.80874C0.562908 8.40939 0.562907 7.59061 1.11201 7.19126Z"/></svg></a></li>      
                    <li class="pager__item pager__item--control pager__item--last"><a href="/planet/page/6" title="Go to last page" class="pager__link"><span class="visually-hidden">Last page</span><svg xmlns="http://www.w3.org/2000/svg" width="15px" height="16px" viewBox="0 0 15 16"><path d="M5.1,7.2l8.3-6C14.1,0.7,15,1.1,15,2V14c0,0.8-0.9,1.3-1.6,0.8l-8.3-6C4.6,8.4,4.6,7.6,5.1,7.2z M0,0h2v16H0V0z"/></svg></a></li>          </ul>
  </nav>

              <div class="feed-icons">
      


<a href="https://joachim-n.github.io/planet/feed" class="feed-icon">
  <span class="feed-icon__label">
    Joachim&amp;#039;s blog
  </span>
  <span class="feed-icon__icon" aria-hidden="true">
    <svg xmlns="http://www.w3.org/2000/svg" width="14.2" height="14.2" viewBox="0 0 14.2 14.2">
  <path d="M4,12.2c0-2.5-3.9-2.4-3.9,0C0.1,14.7,4,14.6,4,12.2z M9.1,13.4C8.7,9,5.2,5.5,0.8,5.1c-1,0-1,2.7-0.1,2.7c3.1,0.3,5.5,2.7,5.8,5.8c0,0.7,2.1,0.7,2.5,0.3C9.1,13.7,9.1,13.6,9.1,13.4z M14.2,13.5c-0.1-3.5-1.6-6.9-4.1-9.3C7.6,1.7,4.3,0.2,0.8,0c-1,0-1,2.6-0.1,2.6c5.8,0.3,10.5,5,10.8,10.8C11.5,14.5,14.3,14.4,14.2,13.5z"/>
</svg>
  </span>
</a>

    </div>
  </div>
</div>

    </div>
  </div>

  </div>

              </main>
                        
          </div>
        </div>
        <div class="social-bar">
          
        </div>
      </div>
    </div>

    <footer class="site-footer">
      <div class="site-footer__inner container">
        

  <div class="region region--footer-top grid-full layout--pass--content-medium">
    <div class="region--footer_top__inner">
      

<div id="block-joachim-blog-theme-powered" class="block block-system block-system-powered-by-block">
  
    
    
  <span>
    Powered by    <a href="https://www.drupal.org">Drupal</a>
    <span class="drupal-logo" role="img" aria-label="Drupal Logo">
      <svg width="14" height="19" viewBox="0 0 42.15 55.08" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M29.75 11.73C25.87 7.86 22.18 4.16 21.08 0 20 4.16 16.28 7.86 12.4 11.73 6.59 17.54 0 24.12 0 34a21.08 21.08 0 1042.15 0c0-9.88-6.59-16.46-12.4-22.27zM10.84 35.92a14.13 14.13 0 00-1.65 2.62.54.54 0 01-.36.3h-.18c-.47 0-1-.92-1-.92-.14-.22-.27-.45-.4-.69l-.09-.19C5.94 34.25 7 30.28 7 30.28a17.42 17.42 0 012.52-5.41 31.53 31.53 0 012.28-3l1 1 4.72 4.82a.54.54 0 010 .72l-4.93 5.47zm10.48 13.81a7.29 7.29 0 01-5.4-12.14c1.54-1.83 3.42-3.63 5.46-6 2.42 2.58 4 4.35 5.55 6.29a3.08 3.08 0 01.32.48 7.15 7.15 0 011.3 4.12 7.23 7.23 0 01-7.23 7.25zM35 38.14a.84.84 0 01-.67.58h-.14a1.22 1.22 0 01-.68-.55 37.77 37.77 0 00-4.28-5.31l-1.93-2-6.41-6.65a54 54 0 01-3.84-3.94 1.3 1.3 0 00-.1-.15 3.84 3.84 0 01-.51-1v-.19a3.4 3.4 0 011-3c1.24-1.24 2.49-2.49 3.67-3.79 1.3 1.44 2.69 2.82 4.06 4.19a57.6 57.6 0 017.55 8.58A16 16 0 0135.65 34a14.55 14.55 0 01-.65 4.14z"/>
</svg>
    </span>
  </span>
</div>

    </div>
  </div>

        
      </div>
    </footer>

    <div class="overlay" data-drupal-selector="overlay"></div>

  </div>
</div>

  </div>

    
    <script type="application/json" data-drupal-selector="drupal-settings-json">{"path":{"baseUrl":"\/","pathPrefix":"","currentPath":"planet","currentPathIsAdmin":false,"isFront":false,"currentLanguage":"en","currentQuery":{"page":"2"}},"pluralDelimiter":"\u0003","suppressDeprecationErrors":true,"user":{"uid":0,"permissionsHash":"01dd47ecd9bcd15f4ce2dda67f9266a98e8b92ff7b9c64558fb5367373af7d61"}}</script>
<script src="/sites/default/files/js/js_8VAq5rHg72u4MA8hrGwHx9Lz8WNC8wFO7od1Rvg4xTA.js?scope=footer&amp;delta=0&amp;language=en&amp;theme=joachim_blog_theme&amp;include=eJxLzk9JTcvMKUkt0k-GM3Wy8hOTMzJz45Ny8tPjSzJSc1P103PykxJzdItLKnMy89IBYRsVxQ"></script>

  </body>
</html>
